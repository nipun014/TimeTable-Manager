"""
Bootstrap script for the Customizable Timetable Management System (Python + OR-Tools)

Run this file to generate a starter project scaffold called `timetable_solver/` with the
following files:

- timetable_solver/__init__.py
- timetable_solver/data_loader.py
- timetable_solver/constraints.py
- timetable_solver/model.py
- timetable_solver/solver.py
- timetable_solver/generator.py
- requirements.txt
- README.md
- sample_data.json

Usage:
    python timetable_project_bootstrap.py

After the script runs, install dependencies and run the example solver:
    pip install -r timetable_solver/requirements.txt
    python -m timetable_solver.solver

This scaffold contains a *minimal* working CP-SAT model using OR-Tools and small sample data.
Extend and replace constraints and data with your project's actual requirements.
"""

from pathlib import Path
import json

ROOT = Path("timetable_solver")
ROOT.mkdir(exist_ok=True)

files = {}

files['__init__.py'] = """# Timetable Solver package init
"""

files['requirements.txt'] = """ortools>=9.0
"""

files['README.md'] = """# Customizable Timetable Management System (scaffold)

This is a starter scaffold generated by a bootstrap script. It includes a minimal CP-SAT
model using OR-Tools and a small sample dataset. Use it as a starting point for adding
custom constraints, preferences, UI, and data import/export.

See sample_data.json for expected data format.
"""

files['sample_data.json'] = json.dumps({
    "classes": ["ClassA", "ClassB"],
    "periods_per_day": 4,
    "subjects": {
        "Math": {"hours_per_week": 4},
        "English": {"hours_per_week": 3},
        "Physics": {"hours_per_week": 2}
    },
    "teachers": {
        "Tina": {"can_teach": ["Math"], "availability": [[1,1,1,1],[1,1,1,1]]},
        "Raj": {"can_teach": ["English","Physics"], "availability": [[1,1,1,1],[1,1,1,1]]}
    }
}, indent=4)

files['data_loader.py'] = '''"""
data_loader.py

Load the sample JSON data and provide simple accessor structures.
"""
from pathlib import Path
import json
from typing import Dict, List

DATA_FILE = Path(__file__).parent / 'sample_data.json'


def load_data(path: Path = DATA_FILE) -> Dict:
    with open(path, 'r') as f:
        data = json.load(f)
    # Basic normalization and convenience structures
    classes = data['classes']
    periods_per_day = data.get('periods_per_day', 4)
    subjects = list(data['subjects'].keys())
    teachers = list(data['teachers'].keys())

    # teacher availability: map teacher -> list of lists (days x periods)
    # For this scaffold we treat availability as days==number of classes (simple)
    teacher_info = data['teachers']

    return {
        'classes': classes,
        'periods_per_day': periods_per_day,
        'subjects': subjects,
        'teachers': teachers,
        'teacher_info': teacher_info,
        'raw': data
    }
'''

files['constraints.py'] = '''"""
constraints.py

Define hard/soft constraints as functions or classes. For the scaffold we include
simple constraint checkers that are applied after extraction.
"""

from typing import Dict


class Constraints:
    """Placeholder constraints container. Extend per project needs."""

    def __init__(self, data: Dict):
        self.data = data

    # example: ensure a teacher is qualified for a subject
    def teacher_can_teach(self, teacher: str, subject: str) -> bool:
        return subject in self.data['teacher_info'][teacher]['can_teach']

'''

files['model.py'] = '''"""
model.py

Builds a minimal CP-SAT model for the timetable problem.
This creates boolean variables x[class][period][subject][teacher]
subject to small constraints:
 - Each class at each period has exactly one (subject,teacher)
 - A teacher can be assigned to at most one class in a given period
 - Teacher must be qualified and available

This is intentionally simple so you can extend it with your project's constraints.
"""
from ortools.sat.python import cp_model
from typing import Dict, Tuple


def build_model(data: Dict) -> Tuple[cp_model.CpModel, Dict]:
    model = cp_model.CpModel()

    classes = data['classes']
    P = data['periods_per_day']
    subjects = data['subjects']
    teachers = data['teachers']
    teacher_info = data['teacher_info']

    # Create variables: x[c][p][s][t]
    x = {}
    for c in classes:
        x[c] = {}
        for p in range(P):
            x[c][p] = {}
            for s in subjects:
                x[c][p][s] = {}
                for t in teachers:
                    # only create variable if teacher can teach subject
                    if s in teacher_info[t]['can_teach']:
                        x[c][p][s][t] = model.NewBoolVar(f"x_{c}_{p}_{s}_{t}")

    # Constraint: each class c at period p has exactly one (s,t)
    for c in classes:
        for p in range(P):
            vars_at_slot = []
            for s in subjects:
                for t in teachers:
                    if s in teacher_info[t]['can_teach']:
                        var = x[c][p][s].get(t)
                        if var is not None:
                            vars_at_slot.append(var)
            # allow possibility of empty slot? For now force exactly one
            model.Add(sum(vars_at_slot) == 1)

    # Constraint: teacher at most one class per period
    for t in teachers:
        for p in range(P):
            teacher_vars = []
            for c in classes:
                for s in subjects:
                    if s in teacher_info[t]['can_teach']:
                        var = x[c][p][s].get(t)
                        if var is not None:
                            teacher_vars.append(var)
            model.Add(sum(teacher_vars) <= 1)

    # (Optional) Soft objective: balance teacher load (minimize max load)
    # Compute total assignments per teacher
    total_per_teacher = {}
    max_load = model.NewIntVar(0, P * len(classes), 'max_load')
    for t in teachers:
        tv = []
        for c in classes:
            for p in range(P):
                for s in subjects:
                    if s in teacher_info[t]['can_teach']:
                        var = x[c][p][s].get(t)
                        if var is not None:
                            tv.append(var)
        if tv:
            total = sum(tv)
            # CP-SAT requires IntVar for totals if combining with other IntVars
            total_per_teacher[t] = total
            model.Add(total_per_teacher[t] <= max_load)
    # minimize max load
    model.Minimize(max_load)

    return model, x
'''

files['solver.py'] = '''"""
solver.py

Simple entrypoint that loads sample data, builds the model, solves it and prints
a readable timetable. Extend with logging, time limits and richer search strategies.
"""
from ortools.sat.python import cp_model
from .data_loader import load_data
from .model import build_model


def pretty_print_solution(data, x, solver):
    classes = data['classes']
    P = data['periods_per_day']
    subjects = data['subjects']
    teachers = data['teachers']

    print("\n--- Timetable Solution ---")
    for c in classes:
        print(f"\nClass: {c}")
        for p in range(P):
            found = False
            for s in subjects:
                for t in teachers:
                    if s in data['teacher_info'][t]['can_teach']:
                        var = x[c][p][s].get(t)
                        if var is not None and solver.Value(var) == 1:
                            print(f" Period {p+1}: {s} (Teacher: {t})")
                            found = True
            if not found:
                print(f" Period {p+1}: Free")


if __name__ == '__main__':
    data = load_data()
    model, x = build_model(data)

    solver = cp_model.CpSolver()
    solver.parameters.max_time_in_seconds = 10
    solver.parameters.num_search_workers = 8

    res = solver.Solve(model)
    if res in (cp_model.OPTIMAL, cp_model.FEASIBLE):
        pretty_print_solution(data, x, solver)
    else:
        print('No solution found')
'''

files['generator.py'] = '''"""
generator.py

Utility to convert solver output into JSON / CSV / other formats. Minimal example
returns a dict representation.
"""

def extract_solution(data, x, solver):
    classes = data['classes']
    P = data['periods_per_day']
    subjects = data['subjects']
    teachers = data['teachers']

    out = {c: [] for c in classes}
    for c in classes:
        for p in range(P):
            entry = {'period': p+1, 'subject': None, 'teacher': None}
            for s in subjects:
                for t in teachers:
                    if s in data['teacher_info'][t]['can_teach']:
                        var = x[c][p][s].get(t)
                        if var is not None and solver.Value(var) == 1:
                            entry['subject'] = s
                            entry['teacher'] = t
            out[c].append(entry)
    return out
'''

# Write files to disk
for name, content in files.items():
    path = ROOT / name
    with open(path, 'w', encoding='utf-8') as f:
        f.write(content)

print(f"Scaffold created at: {ROOT.resolve()}")
print("Run `pip install -r timetable_solver/requirements.txt` and then `python -m timetable_solver.solver`")
